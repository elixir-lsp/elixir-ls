{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ElixirLS","text":"<p>Implementing features such as auto-complete or go-to-definition for a programming language is not trivial. Traditionally, this work had to be repeated for each development tool and it required a mix of expertise in both the targeted programming language and the programming language internally used by the development tool of choice.</p> <p>The Elixir Language Server (ElixirLS) provides a server that runs in the background, providing IDEs, editors, and other tools with information about Elixir Mix projects. It adheres to the LSP, a standard for frontend-independent IDE support. Debugger integration is accomplished through the similar VS Code Debug Protocol.</p> <p>These pages contain all the information needed to configure your favourite text editor or IDE and to work with the ElixirLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.</p>"},{"location":"features/","title":"Features","text":"<ul> <li>Debugger support</li> <li>Automatic, incremental Dialyzer analysis</li> <li>Automatic inline suggestion of @specs based on Dialyzer's inferred success typings</li> <li>Inline reporting of build warnings and errors</li> <li>Documentation lookup on hover</li> <li>Go-to-definition</li> <li>Code completion</li> <li>Code formatter</li> <li>Find references to functions and modules (Thanks to @mattbaker)</li> <li>Quick symbol lookup in file (Thanks to @mattbaker)</li> <li>Quick symbol lookup in workspace and stdlib (both Elixir and erlang) (@lukaszsamson)</li> </ul>"},{"location":"features/#automatic-builds-and-error-reporting","title":"Automatic builds and error reporting","text":"<p>Builds are performed automatically when files are saved. If you want this to happen automatically when you type, you can turn on \"autosave\" in your IDE.</p> <p>Starting in Elixir 1.6, Mix compilers adhere to the Mix.Task.Compiler behaviour and return their error and warning diagnostics in a standardized way. Errors and warnings will be shown inline in your code as well as in the \"Problems\" pane in the IDE. If you're using an earlier version of Elixir, you'll need to look at the text log from the extension to see the errors and warnings.</p>"},{"location":"features/#dialyzer-integration","title":"Dialyzer integration","text":"<p>ElixirLS will automatically analyze your project with Dialyzer after each successful build. It maintains a \"manifest\" file in <code>.elixir_ls/dialyzer_manifest</code> that stores the results of the analysis. The initial analysis for a project can take a few minutes, but after that's completed, modules are re-analyzed only if necessary, so subsequent analyses are typically very fast -- often less than a second. It also looks at your modules' abstract code to determine whether they reference any modules that haven't been analyzed and includes them automatically.</p> <p>You can control which warnings are shown using the <code>elixirLS.dialyzerWarnOpts</code> setting in your project or IDE's <code>settings.json</code>. Find available options in Erlang docs at section \"Warning options\".</p> <p>To disable Dialyzer completely, set <code>elixirLS.dialyzerEnabled</code> to false.</p> <p>Check usage details in Dialyxir docs on GitHub and hexdocs.</p> <p>ElixirLS's Dialyzer integration uses internal, undocumented Dialyzer APIs, and so it won't be robust against changes to these APIs in future Erlang versions.</p>"},{"location":"features/#code-completion","title":"Code completion","text":"<p>ElixirLS bundles an advanced code completion provider. The provider builds on Elixir Sense library and utilizes two main mechanisms. The first one is reflection - getting information about compiled modules from Erlang and Elixir APIs. The second one is AST analysis of the current text buffer. While reflection gives precise results, it is not well suited for on demand completion of symbols from the currently edited file. The compiled version is likely to be outdated or the file may not compile at all. AST analysis helps in that case but it has its limitations. Unfortunately it is infeasible to be 100% accurate, especially with Elixir being a metaprogramming heavy language.</p> <p>The completions include:</p> <ul> <li>keywords</li> <li>special form snippets</li> <li>functions</li> <li>macros</li> <li>modules</li> <li>variables</li> <li>struct fields (only if the struct type is explicitly stated or can be inferred from the variable binding)</li> <li>atom map keys (if map keys can be inferred from variable binding)</li> <li>attributes</li> <li>types (in typespecs)</li> <li>behaviour callbacks (inside the body of implementing module)</li> <li>protocol functions (inside the body of implementing module)</li> <li>keys in keyword functions arguments (if defined in spec)</li> <li>function returns (if defined in spec)</li> </ul>"},{"location":"features/#workspace-symbols","title":"Workspace Symbols","text":"<p>With Dialyzer integration enabled ElixirLS will build an index of symbols (modules, functions, types and callbacks). The symbols are taken from the current workspace, all dependencies and stdlib (Elixir and erlang). This feature enables quick navigation to symbol definitions.</p>"},{"location":"known-issues-limitations/","title":"Known Issues / Limitations","text":"<ul> <li><code>.exs</code> files don't return compilation errors</li> <li>\"Fetching n dependencies\" sometimes get stuck (remove the <code>.elixir_ls</code> directory to fix)</li> <li>Debugger doesn't work in Elixir 1.10.0 - 1.10.2 (but it should work in 1.10.3 when this fix is released)</li> <li>\"Go to definition\" does not work within the <code>scope</code> of a Phoenix router</li> <li>On first launch dialyzer will cause high CPU usage for a considerable time</li> <li>Dialyzer does not pick up changes involving remote types (https://github.com/elixir-lsp/elixir-ls/issues/502)</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Basic troubleshooting steps:</p> <ul> <li>Restart your editor (which will restart ElixirLS)</li> <li>After stopping your editor, remove the entire <code>.elixir_ls</code> directory, then restart your editor</li> <li>NOTE: This will cause you to have to re-run the entire dialyzer build</li> </ul> <p>If your code doesn't compile in ElixirLS, it may be because ElixirLS compiles code with <code>MIX_ENV=test</code> (by default). So if you are missing some configuration in the test environment, your code may not compile.</p> <p>If you get an error like the following immediately on startup:</p> <pre><code>[Warn  - 1:56:04 PM] ** (exit) exited in: GenServer.call(ElixirLS.LanguageServer.JsonRpc, {:packet, %{...snip...}}, 5000)\n    ** (EXIT) no process: the process is not alive or there's no process currently associated with the given name, possibly because its application isn't started\n</code></pre> <p>and you installed Elixir and Erlang from the Erlang Solutions repository, you may not have a full installation of erlang. This can be solved with <code>sudo apt-get install esl-erlang</code>. Originally reported in #208.</p> <p>On fedora if you only install the elixir package you will not have a full erlang installation, this can be fixed by running <code>sudo dnf install erlang</code> (reported in #231)</p> <p>If you are using Emacs with lsp-mode there's a possibility that you have set the wrong directory as the project root (especially if that directory does not have a <code>mix.exs</code> file). To fix that you should remove the project and re-initialize:</p> <p>https://github.com/elixir-lsp/elixir-ls/issues/364#issuecomment-829589139</p>"},{"location":"getting-started/emacs/","title":"Emacs","text":""},{"location":"getting-started/emacs/#setup","title":"Setup","text":"<p>Download the latest release:   <code>https://github.com/elixir-lsp/elixir-ls/releases/latest</code> and unzip it into a   directory (this is the directory referred to as the   <code>\"path-to-elixir-ls/release\"</code> below)</p> <p>If using <code>lsp-mode</code> add this configuration: <pre><code>(use-package lsp-mode\n  :commands lsp\n  :ensure t\n  :diminish lsp-mode\n  :hook\n  (elixir-mode . lsp)\n  :init\n  (add-to-list 'exec-path \"path-to-elixir-ls/release\"))\n</code></pre></p> <p>For <code>eglot</code> users: <pre><code>(require 'eglot)\n;; This is optional. It automatically runs `M-x eglot` for you whenever you are in `elixir-mode`\n(add-hook 'elixir-mode-hook 'eglot-ensure)\n;; Make sure to edit the path appropriately, use the .bat script instead for Windows\n(add-to-list 'eglot-server-programs '(elixir-mode \"path-to-elixir-ls/release/language_server.sh\"))\n</code></pre></p> <p>The official <code>lsp-mode</code> package includes a client for the Elixir Language Server.</p> <p>Whenever opening a project for the first time, you will be prompted by <code>emacs-lsp</code> to select the correct project root. In that occasion, you also have the opportunity to blacklist projects. Information about projects is stored in a file pointed by the <code>lsp-session-file</code> variable. Its default location is <code>~/.emacs.d/.lsp-session-v1</code>. You may need to prune or amend this file if you change your mind about blacklisting a project or if you erroneously select a project root. For more information about the <code>lsp-session-file</code> and <code>emacs-lsp</code> in general, please refer to the official documentation.</p> <p>Remember that ElixirLS requires Erlang/OTP 22 and Elixir 1.10.0 or higher to run, so ensure that Erlang and Elixir are available in your <code>PATH</code>. This can be achieved, for example, by using the exec-path-from-shell Emacs package.</p>"},{"location":"getting-started/emacs/#restarting-the-language-server","title":"Restarting the language server","text":"<p>You may want to quickly restart the language server for a given workspace (e.g. after an update or in case of a server crash). To do so:</p> <pre><code>M-x lsp-workspace-restart\n</code></pre>"},{"location":"getting-started/emacs/#troubleshooting","title":"Troubleshooting","text":"<p>To be sure that you don't have outdated or incompatible packages installed, you may also want to rename your <code>~/.emacs.d</code> directory while you are troubleshooting your ElixirLS Emacs setup.</p> <p>Also, ensure that Erlang, Elixir (i.e. <code>erl</code>, <code>escript</code> and friends) and the <code>language_server.sh</code> script are all available in your <code>PATH</code>. If they are not, you can try the following:</p> <pre><code>;; Ensure your Emacs environment looks like your user's shell one\n(package-require 'exec-path-from-shell)\n(exec-path-from-shell-initialize)\n</code></pre> <p>Finally, to enable logging on the client-side, just:</p> <pre><code>(setq lsp-log-io t)\n</code></pre> <p>You can then follow the client logs for the current workspace by doing:</p> <pre><code>M-x lsp-workspace-show-log\n</code></pre>"},{"location":"getting-started/emacs/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"getting-started/emacs/#shortcuts-for-code-lenses-and-quick-actions","title":"Shortcuts for code lenses and quick actions","text":"<p>You can run <code>M-x lsp-avy-lens</code> to show letters next to code lenses. You can then press those letters to trigger the respective action.</p> <p>If your <code>sideline</code> is enabled (<code>(setq lsp-ui-sideline-enable t)</code>), you can also use <code>M-x lsp-execute-code-action</code> to trigger quick-fix actions.</p>"},{"location":"getting-started/kakoune/","title":"Kakoune","text":""},{"location":"getting-started/kakoune/#setup","title":"Setup","text":"<p>Install the kak-lsp client for the Kakoune editor.</p>"},{"location":"getting-started/kakoune/#limitations","title":"Limitations","text":""},{"location":"getting-started/kakoune/#encoding","title":"Encoding","text":"<p>kak-lsp works only with UTF-8 documents.</p>"},{"location":"getting-started/kakoune/#positioncharacter-interpretation","title":"<code>Position.character</code> interpretation","text":"<p>Currently, kak-lsp doesn't conform to the spec regarding the interpretation of <code>Position.character</code>. LSP spec says that</p> <p>A position inside a document (see Position definition below) is expressed as a zero-based line and character offset. The offsets are based on a UTF-16 string representation. So for a string of the form <code>a\ud801\udc00b</code> the character offset of the character <code>a</code> is 0, the character offset of <code>\ud801\udc00</code> is 1 and the character offset of <code>b</code> is 3 since <code>\ud801\udc00</code> is represented using two code units in UTF-16.</p> <p>However, kak-lsp treats <code>Position.character</code> as an offset in UTF-8 code points by default. Fortunately, it appears to produce the same result within the Basic Multilingual Plane (BMP) which includes a lot of characters.</p> <p>Unfortunately, many language servers violate the spec as well, and in an inconsistent manner. Please refer https://github.com/Microsoft/language-server-protocol/issues/376 for more information. There are two main types of violations we met in the wild:</p> <p>1) Using UTF-8 code points, just like kak-lsp does. Those should work well with kak-lsp for characters outside BMP out of the box.</p> <p>2) Using UTF-8 code units (bytes), just like Kakoune does. Those are supported by kak-lsp but require adding <code>offset_encoding = \"utf-8\"</code> to the language server configuration in <code>kak-lsp.toml</code>.</p>"},{"location":"getting-started/kate/","title":"Kate","text":""},{"location":"getting-started/kate/#setup","title":"Setup","text":"<p>Use the built-in LSP client for Kate.</p>"},{"location":"getting-started/neovim/","title":"NeoVim","text":""},{"location":"getting-started/neovim/#setup","title":"Setup","text":"<p>There are several plugins available for NeoVim:</p> Plugin Notes coc.nvim Does not support debug adapter nvim-dap Only debug adapter ALE Does not support debug adapter or typespec suggestions elixir-lsp/coc-elixir Does not support debug adapter vim-lsp Does not support debug adapter"},{"location":"getting-started/nova/","title":"Nova","text":""},{"location":"getting-started/nova/#setup","title":"Setup","text":"<p>Install the extension for Nova.</p>"},{"location":"getting-started/overview/","title":"Getting Started","text":"<p>The Erlang LS language server works with all text editors and IDEs which adhere to the LSP protocol. The list of supported editors include Emacs, Vim, VS Code, Sublime Text 3 and more.</p> <p>These pages contain all the information needed to configure your favourite text editor or IDE to use ErlangLS. You will also find instructions on how to configure the server to recognize the structure of your projects and to troubleshoot your installation when things do not work as expected.</p> <ul> <li>Emacs</li> <li>Kakoune</li> <li>Kate</li> <li>Neovim</li> <li>Nova</li> <li>Sublime Text 3</li> <li>VS Code</li> </ul>"},{"location":"getting-started/sublime/","title":"Sublime","text":""},{"location":"getting-started/sublime/#setup","title":"Setup","text":"<p>Install the extension LSP-Elixir.</p> <p>Note that it does not have debug adapter support.</p>"},{"location":"getting-started/vscode/","title":"VSCode","text":""},{"location":"getting-started/vscode/#setup","title":"Setup","text":"<p>Install the official ElixirLS extension and enable it.</p>"},{"location":"getting-started/vscode/#debugger","title":"Debugger","text":"<p>ElixirLS includes debug adapter support adhering to the Debug Adapter Protocol which is closely related to the Language Server Protocol.</p> <p>When debugging in Elixir or Erlang, only modules that have been \"interpreted\" (using <code>:int.ni/1</code> or <code>:int.i/1</code>) will accept breakpoints or show up in stack traces. The debugger in ElixirLS automatically interprets all modules in the Mix project and dependencies prior to launching the Mix task, so you can set breakpoints anywhere in your project or dependency modules.</p> <p>In order to debug modules in <code>.exs</code> files (such as tests), they must be specified under <code>requireFiles</code> in your launch configuration so they can be loaded and interpreted prior to running the task. For example, the default launch configuration for \"mix test\" in the VS Code plugin looks like this:</p> <pre><code>{\n  \"type\": \"mix_task\",\n  \"name\": \"mix test\",\n  \"request\": \"launch\",\n  \"task\": \"test\",\n  \"taskArgs\": [\"--trace\"],\n  \"projectDir\": \"${workspaceRoot}\",\n  \"requireFiles\": [\n    \"test/**/test_helper.exs\",\n    \"test/**/*_test.exs\"\n  ]\n}\n</code></pre> <p>In order to debug a single test or a single test file it is currently necessary to modify <code>taskArgs</code> and make sure no other tests are required in <code>requireFiles</code>.</p> <pre><code>{\n  \"type\": \"mix_task\",\n  \"name\": \"mix test\",\n  \"request\": \"launch\",\n  \"task\": \"test\",\n  \"taskArgs\": [\"tests/some_test.exs:123\"],\n  \"projectDir\": \"${workspaceRoot}\",\n  \"requireFiles\": [\n    \"test/**/test_helper.exs\",\n    \"test/some_test.exs\"\n  ]\n}\n</code></pre> <p>Please note that due to <code>:int</code> limitation NIF modules cannot be interpreted and need to be excluded via <code>excludeModules</code> option. This option can be also used to disable interpreting for some modules when it is not desirable e.g. when performance is not satisfactory.</p> <pre><code>{\n  \"type\": \"mix_task\",\n  \"name\": \"mix test\",\n  \"request\": \"launch\",\n  \"task\": \"test\",\n  \"taskArgs\": [\"--trace\"],\n  \"projectDir\": \"${workspaceRoot}\",\n  \"requireFiles\": [\n    \"test/**/test_helper.exs\",\n    \"test/**/*_test.exs\"\n  ],\n  \"excludeModules\": [\n    \":some_nif\",\n    \"Some.SlowModule\"\n  ]\n}\n</code></pre>"}]}